<!DOCTYPE html>

<html>
    <head>
        <link href="notes.css" rel="stylesheet"/>

    </head>
    <body>
    <h2>Problem Solving</h2>
        <ul>
            <li><b>Polya's Process</b>: Method for solving problems developed by George Polya</li>
            <ol>
                <li class="key-concept">Understand the Problem:  </li>
                    <ul>
                        <li>Re-read, research, or self-explain the problem until it is understood</li>
                        <li>Determine unknowns and knowns (available data)</li>
                        <li>Determine if available data is sufficient to solve unknowns</li>
                    </ul>
                <li class="key-concept">Make a Plan: </li>
                    <ul>
                        <li>Consider if a similar problem has been previously addressed or if there is an existing framework</li>
                        <li>Break problem down into smaller pieces that can be solved independently (pseudo-code)</li>
                    </ul>
                <li class="key-concept">Carry out the Plan:</li>
                    <ul>
                        <li>Execute plan by solving smaller pieces. Evaluate results against what was expected</li>
                        <li>Debug often to avoid catastrophic outcome when consolidating results.</li>
                    </ul>
                <li class="key-concept">Review Solution:</li>
                    <ul>
                        <li>If possible, check-fig or prove result is correct</li>
                        <li>Optimize and generalize the completed answer,</li>
                    </ul>
            </ol>
        </ul>

    <h2>Git and Github</h2>
        <ul>
            <li>Git</li>
                <ul>
                    <li>'brand' of version control</li>
                    <li>Saves groups of changes (since the last time there was a commit)</li>
                    <li>Triggered manually</li>
                    <li>Creates a chain of history that allows one to go back to a specific commit</li>
                    <li>Intelligently combines changes from different source - asks specifically about conflicts</li>
                    <li><span class="code">'git init'</span></li>
                    <ul>
                        <li>Initializes new git repository in local directory</li>
                    </ul>
                    <li><span class="code">'git status'</span></li>
                    <ul>
                        <li>Shows status of project from perspective of git</li>
                    </ul>
                    <li><span class="code">'git add file-name'</span> or <span class="code">'git add -A'</span></li>
                    <ul>
                        <li>Staging files for commit - allows you to pick and choose what will be committed. Adding ' -A' stages all files</li>
                    </ul>
                    <li><span class="code">'git commit -m "meaningful message that describes changes here"'</span></li>
                    <ul>
                        <li>commits staged files, note that -m "message" flag is required and should include brief description of what was changed</li>
                    </ul>
                    <li><span class="code">'git log'</span></li>
                    <ul>
                        <li>shows log of previous commits</li>
                    </ul>
                    <li><span class="code">'git remote add origin URL_TO_GITHUB'</span></li>
                    <ul>
                        <li>Creates remote connection between local git folder and github</li>
                        <li>Example using HTTPS (requires periodic login): 'git remote add origin https://github.com/vbuongiovanni/vs-level-1.git'</li>
                        <li>Example without SSH Key (requires set up of key file, must be initialized locally, then copy-pasted to github): 'git remote add origin git@github.com:vbuongiovanni/vs-level-1.git'</li>
                    </ul>
                    <li><span class="code">'git remote -v'</span></li>
                    <ul>
                        <li>Shows details and permission of remote connection between local and Github. can be used to verify 'git remote add' worked</li>
                    </ul>
                    <li><span class="code">'git push -u origin master'</span></li>
                    <ul>
                        <li>Required for initial setup of repo, initializes git push command</li>
                    </ul>
                    <li><span class="code">'git push'</span></li>
                    <ul>
                        <li>Pushes commits to repository. In this case, Github</li>
                    </ul>


                </ul>
            <li>Github</li>
                <ul>
                    <li>Online repositories of project - uses git</li>
                    <li>Facilitates collaboration between team members or the public</li>
                </ul>
        </ul>

    <h2>Elements, Console, and Sources</h2>
        <ul>
            <li>Google Chrome Dev Tools:</li>
            <ol>
                <li><b>Elements tab</b> - focuses on the HTML and CSS aspects (color picker, element names, class names, etc.)</li>
                <li><b>Console</b> - first place to look in event of JS not working quite right. Check for errors</li>
                <li><b>Sources tab</b> - Allows us to look at JS file line by line. Can also access .css file</li>
                    <ul>
                        <li>This is also the best way to determine whether or not external files are actually linking</li>
                        <li>you can also use <b>breakpoints</b>, which will make the browser <em>pause</em> the JS script at a certain point and allow to gradually work through step by step or line by line.</li>
                    </ul>
            </ol>
        </ul>

    <h2 class="key-concept">HTML</h2>
        <ul>
            <li>lower case all html element, attributes, tags etc. One exception - the DOCTYPE at the start of the page </li>
            <li>Names should be broken up with a dash</li>
        </ul>
    <h2 class="key-concept">CSS</h2>
        <ul>
            <li class="key-concept">Box Model</li>
                <ul>
                    <li>Elements of the Box Model</li>
                    <ul>
                        <li class="key-concept">Content</li>
                        <ul>
                            <li>Area where the text or content resides</li>
                            <li>Determined by height and width</li>
                            <li>If there aren't any elements (e.g., text, pictures, etc.), then height will equal 0</li>
                        </ul>
                        <li class="key-concept">Padding</li>
                        <ul>
                            <li>Blank space around content - inherents the same background color as content element</li>
                            <li>Still considered to be part of the element itself. If padding is increased, the element's size will increase</li>
                        </ul>
                        <li class="key-concept">Border</li>
                        <ul>
                            <li>Akin to the plastic walls of someone wearing a bubble suit - it is the final boundary between the enclosed element and the outside world</li>
                            <li>Note that even if border is '0px', if there is a linear border, it will count as a percent of the screen. You can override this by defining <span class="css-code">* {box-sizing: border-box;}</span> </li>
                        </ul>
                        <li class="key-concept">Margin</li>
                        <ul>
                            <li>Spacer between elements - not that increasing margin does NOT change the size of the object, just the empty space around the object</li>
                        </ul>
                    </ul>
                    <li>Defining Properties - Shortcuts:</li>
                    <ul>
                        <li>Single Value: applies size to all sides - <span class="css-code">margin: 10px;</span></li>
                        <li>Two Values: applies first value to Top and Bottom, and second value to Left and Right <span class="css-code">margin: 10px 20px;</span></li>
                        <li>Three Values: applies first value to Top, second value to Bottom, and third value to both Left and Right <span class="css-code">margin: 10px 20px 30px;</span></li>
                        <li>Four Values: defines Top, Right, Bottom, and Left <span class="css-code">margin: 10px 20px 30px 40px</span></li>
                    </ul>
                </ul>
            <li class="key-concept">Positioning</li>
                <ul>
                    
                    <li class="key-concept">static</li>
                    <ul>
                        <li>Default position of elements</li>
                    </ul>
                    <li>By defining these, we gain access to the top, bottom, left, and right properties</li>
                    <li class="key-concept">Relative</li>
                    <ul>
                        <li>leaves elements where they fall naturally, unless they are then further specified by the top, bottom, left, and right properties</li>
                    </ul>
                    <li class="key-concept">Absolute</li>
                    <ul>
                        <li>positions element with respect to window.</li>
                        <li>Other elements will push to fill in the place of the original element as if it doesn't exists</li>
                    </ul>
                    <li class="key-concept">Fixed</li>
                    <ul>
                        <li>Look exactly like absolute except that it will remain in the same place regardless of scrolling.</li>
                        <li>This is how you create a sticky navbar or sticky header</li>
                    </ul>
                </ul>
            <li class="key-concept">Responsive Styling Design</li>
                <ul>
                    <li>Intuition of responsive design is that the screen should be able to work on any sized screen.</li>
                    <li>Design practice of <b>Mobile First</b>, which means that we design web apps for mobile-sized screens first, then design larger screens next.</li>
                    <li>Responsive styling is originated by adding <span code="css-code">@media</span> to the beginning of a CSS statement</li>
                    <li>Since some older browsers do not support dynamic styling, the <span code="css-code">only</span> keyword can be added after <span code="css-code">@media</span>. This will negate the responsive design, rather than breaking the styling sheet, if the browser doesn't support responsive design.</li>
                    <li>The <b>media type</b> also be specified to apply styling to either <span class="css-code">print</span>, <span class="css-code">screen</span>, or <span class="css-code">all</span> (implied by default). The media type is defined immediately after the <span code="css-code">only</span></li>
                    <li>Multiple conditions can be added with the <span code="css-code">and</span> operator </li>
                    <li>Example:</li>
                    <p class="css-code">@media only screen and (max-width: 599px) {</p>
                    <p class="css-code css-level-1">div {</p>
                    <p class="css-code css-level-2">background-color: green;</p>
                    <p class="css-code css-level-1">}</p>
                    <p class="css-code">}</p>
                    <p class="css-code">@media only screen and (min-width: 600px) and (max-width: 649px) {</p>
                    <p class="css-code css-level-1">div {</p>
                    <p class="css-code css-level-2">background-color: firebrick;</p>
                    <p class="css-code css-level-1">}</p>
                    <p class="css-code">}</p>
                    <p class="css-code">@media only screen and (min-width: 650px) and (max-width: 850px) {</p>
                    <p class="css-code css-level-1">div {</p>
                    <p class="css-code css-level-2">background-color: cornflowerblue;</p>
                    <p class="css-code css-level-1">}</p>
                    <p class="css-code">}</p>
                    <p class="css-code">@media only screen and (min-width: 851px) {</p>
                    <p class="css-code css-level-1">div {</p>
                    <p class="css-code css-level-2">background-color: purple;</p>
                    <p class="css-code css-level-1">}</p>
                    <p class="css-code">}</p>
                    <div id="responsive-design-box-dont-delete">
                        <p></p>
                    </div>

                    
                </ul>
            <li class="key-Concept">CSS Selectors</li>
                <ul>
                    <li class="key-concept">Basic Selectors</li>
                    <ul>
                        <li>Select all HTML elements of a given tag: <span class="css-code">html.tag {background-color: white;}</span></li>
                        <ul>
                            <li>Example: div elements: <span class="css-code">div {background-color: white;}</span></li>
                        </ul>
                        <li>Select all elements with a given class: <span class="css-code">.html-class-name {background-color: white;}</span></li>
                        <ul>
                            <li>Example: select all elements with a class name of 'important-list-items': <span class="css-code">.important-list-items {background-color: white;}</span></li>
                        </ul>
                        <li>Select all elements with a given html ID: <span class="css-code">#html-id-name {background-color: white;}</span></li>
                        <ul>
                            <li>Example: select all elements (should only be one) with an ID name of 'earnings': <span class="css-code">#earnings-input {background-color: white;}</span></li>
                        </ul>
                    </ul>
                    <li class="key-concept">Combining Selectors</li>
                    <ul>
                        <li>Descendant Combinator - Select all X descendants of Y: <span class="css-code">Y X {background-color: white;}</span></li>
                        <ul>
                            <li>Example: this will select all li elements that exist within the ul elements: <span class="css-code">ul li {background-color: white;}</span></li>
                        </ul>
                        <li>Wildcare Descendant Combinator - Select all elements that are descendants of Y: <span class="css-code">Y * {background-color: white;}</span></li>
                        <ul>
                            <li>Example: this will select all elements that exist within the ul elements on the page: <span class="css-code">ul * {background-color: white;}</span></li>
                        </ul>
                        <li>Difference Combinator - Select only direct elements of X that are descendants of Y: <span class="css-code">Y > X {background-color: white;}</span></li>
                        <ul>
                            <li>Example: this will select all li elements that exist within the ul elements on the page (sub elements will be ignored): <span class="css-code">ul > li {background-color: white;}</span></li>
                        </ul>
                        <li>Adjacent Combinator - Selects element that is immediately preceded by former, or the first X with each Y: <span class="css-code">Y + X {background-color: white;}</span></li>
                        <ul>
                            <li>Example: this will select the first li element within each ul element on the page: <span class="css-code">ul + li {background-color: white;}</span></li>
                        </ul>
                        <li>Multi Selection - Selects all X and Y elements. Can be chained as long as needed: <span class="css-code">Y, X {background-color: white;}</span></li>
                        <ul>
                            <li>Example: this will select all ul and ol elements: <span class="css-code">ul, li {background-color: white;}</span></li>
                        </ul>
                        <li>Sibling Selector - Selects all X element, but only if it is immediately contained within a Y element. <span class="css-code">Y ~ X {background-color: white;}</span></li>
                        <ul>
                            <li>Example: this will select all p elements, but only if it is contained directly within a div element: <span class="css-code">div ~ p {background-color: white;}</span></li>
                        </ul>
                    </ul>
                </ul>
            <li class="key-concept">Pseudo Selectors and Transitions</li>
                <ul>
                    <li><span>Pseudo Selectors</span> are special CSS properties that can modify the underlying appearance of HTML elements (e.g., <span class="code">:active</span>, <span class="code">:hover</span>)</li>
                    <ul>
                        <li>Pseudo Selector are defined in CSS stylesheet by selecting the element and appending the pseudo class name to the end of the element (e.g, <span class="code">#html-element-id:hover</span></li>
                    </ul>
                    <li><span>Transitions</span> are CSS properties that modify how the changes take place. Transitions allow for smooth and aesthetically pleasing changes to the website rather than sudden changes.</li>
                    <ul>
                        <li>Transitions are defined in CSS stylesheet just like any other property. Properties can either be set long-hand or short hand. see example below.</li>
                        <li>At a high level, the four transition properties are:</li>
                        <ul>
                            <li>transition-property: which property will be changed</li>
                            <li>transition-duration: how long the transition will take to complete</li>
                            <li>transition-timing-function: how will the speed of the transition be configured (default is 'linear')</li>
                            <li>transition-delay: how long after the transition is triggered before it will start</li>
                        </ul>
                        <li>transition properties are not entirely generalized across all browsers, so it is a good idea to use <span class="key-concept">vendor prefixes</span> to ensure cross-browser compatibility.</li>
                    </ul>
                    <li>Example - Long Hand css Transition</li>
                    <p class="css-code">#box {</p>
                    <p class="css-code css-level-1">width: 200px;</p>
                    <p class="css-code css-level-1">height: 200px;</p>
                    <p class="css-code css-level-1">border: 1px solid black;</p>
                    <p class="css-code css-level-1">background-color: cornflowerblue;</p>
                    <p class="css-code css-level-1">transition-property: background-color;</p>
                    <p class="css-code css-level-1">transition-duration: 1s;</p>
                    <p class="css-code css-level-1">transition-timing-function: linear;</p>
                    <p class="css-code css-level-1">transition-delay: 1s;</p>
                    <p class="css-code">}</p>
                    <li>Example - Long Hand css Transition</li>
                    <p class="css-code">#circle {</p>
                    <p class="css-code css-level-1">width: 200px;</p>
                    <p class="css-code css-level-1">height: 200px;</p>
                    <p class="css-code css-level-1">border: 1px solid black;</p>
                    <p class="css-code css-level-1">border-radius: 50%;</p>
                    <p class="css-code css-level-1">background-color: firebrick;</p>
                    <p class="css-code css-level-1">transition-property: background-color;</p>
                    <p class="css-code css-level-1">transition-duration: 1s;</p>
                    <p class="css-code css-level-1">transition-timing-function: linear;</p>
                    <p class="css-code css-level-1">transition-delay: 1s;</p>
                    <p class="css-code">}</p>
                    <li>Example - declaration of pseudo selectors</li>
                    <p class="css-code">#circle:hover {</p>
                    <p class="css-code css-level-1">background-color: cornflowerblue;</p>
                    <p class="css-code">}</p>
                    <p class="css-code">#box:hover {</p>
                    <p class="css-code css-level-1">background-color: firebrick;</p>
                    <p class="css-code">}</p>
                    <p>Hover over shapes to see impact of pseudo selectors and transitions:</p>
                    <div id="css-example-shapes">
                        <div id="box"></div>
                        <div id="circle"></div>
                    </div>
                </ul>

        </ul>

    <h2>The Document Object Model (DOM)</h2>
        <ul>
        <h3>Selecting Elements</h3>
            <li>Selecting A Single DOM Object</li>
            <ul>
                <li><span class="code">document.getElementByID("id-name-here")</span></li>
                <ul>
                    <li>Most common way to make single selection</li>
                    <li>Ideal for single DOM Object, because the id-name should be, in theory, unique</li>
                    <li>If you attempt to call on a nonexistent element, 'null' will return</li>
                </ul>
                <li><span class="code">document.querySelector("css-syntax-here")</span></li>
                <ul>
                    <li>returns single element, regardless of how many instances exist (first match is returned)</li>
                    <li>All css selection syntax applies - "#id-name", ".class-name", "html-tag", "html-tag.class-name", "ol#favorite-things > li"</li>
                </ul>
            </ul>
            <li>Selecting Multiple DOM Objects</li>
            <ul>    
                <li><span class="code">document.getElementsByTagName("html-tag"); document.getElementsByClassName("class-name"); document.getElementsByName("element-name"); </span></li>
                <ul>
                    <li>Two most common ways are using either '.getElementsByClassName' or '.getElementsByTagName' methods</li>
                    <li>Returns an HTMLCollection, which is effective just an array of single items from DOM</li>
                    <li>If you attempt to call one of these methods on a nonexistent element, an array of length 0 will return</li>
                </ul>
                <li><span class="code">document.querySelectorAll("css-syntax-here")</span></li>
                <ul>
                    <li>returns a NodeList object that consists of all elements that match the query</li>
                    <li>All css selection syntax applies - "#id-name", ".class-name", "html-tag", "html-tag.class-name", "ol#favorite-things > li"</li>
                </ul>
            </ul>
            
        <h3>Modifying HTML from JS</h3>
            
            <li>Modifying Text & Values</li>
            <ul>
                <li>Accessing and Modifying <b>content</b> that exists within the webpage:</li>
                <ul>
                    <li>There are three primary properties that can be used to modify textual content:</li>
                    <ol>
                        <li><span class="code">domObject.textContent</span></li>
                            <ul>
                                <li>Best option for changing text of HTML element</li>
                                <li> When used in console.log, the result will show VALUES of content, even if content is nested in child element.</li>
                            </ul>
                        <li><span class="code">domObject.innerHTML</span></li>
                            <ul>
                                <li>Can be a security risk, so usually best to avoid... but many examples use it, so don't be surprised when it comes up</li>
                                <li>When used in console.log, the result will show raw HTML of DOM element</li>
                                <li>Provides a string representation of HTML. However, that said, innerHTML can be used to add new elements to an existing page.</li>
                                <li>Less efficient than .textContent, but not really noticeable unless it is a large scale process </li>
                            </ul>
                        <li><span class="code">domObject.innerText</span></li>
                            <ul>
                                <li>can be computationally extensive</li>
                            </ul>
                    </ol>
                </ul>
                <li>Accessing and Modifying <b>values</b> that exists within inputs fields:</li>
                <ul>
                    <li>Contrary to HTML content text, input values are accessed via the 'value' property within the DOM object</li>
                        <ul>
                            <li>The value can be accessed via 'document.getElementById("some-id").value'</li>
                            <li>Just like virtually any other property, this can be redefined in JS</li>
                        </ul>
                </ul>
            </ul>

            <li>Modifying Styles</li>
                <ol>
                    <li><span class="code">domObject.style</span></li>
                    <ul>
                        <li>Within any DOM object, there is a .style object that stores the CSS properties</li>
                        <li>These properties can be changed in the .JS file via javascript. Note that you must follow the CSS parameter naming conventions</li>
                        <li>The name of the properties  mirror the CSS names, with the exception that the names follow JS convention (camelCase) rather than HTMl/CSS ("-" seperated lower case)</li>
                    </ul>
                    <li><span class="code">domObject.className</span> and <span class="code">domObject.classList</span></li>
                    <ul>
                        <li><span class="code">domObject.className</span> (least preferred)</li>
                        <ul>
                            <li>Shows the name of the class(s), however all classes are shown in a single string and space separated</li>
                            <li>The class(s) can be modified by changing the .className value of DOM Object:</li>
                            <li>Note - it can be problematic to REMOVE elements, since it is all shown in a single string.</li>    
                        </ul>
                        <li><span class="code">domObject.classList</span> (preferred)</li>
                        <ul>
                            <li>provides a 'DOMTokenList' or an object with key-value pairs representing the class names</li>
                            <li>Object comes with various methods that make modifications much easier.</li>
                        </ul>
                    </ul>
                </ol>

        <h3>Creating New Elements in JS</h3>
            <ul>
                <li>New elements can be added and modified via JS using the DOM. In general, there are 4 steps:</li>
                <ol>
                    <li>Create and save new element - <span class="code">const newListItem = document.createElement("li")</span></li>
                    <li>Find reference element - <span class="code">const existingListElement = document.getElementById("grocery-list")</span></li>
                    <li>Place new element into DOM by using one of the many available methods:</li>
                    <ul>
                        <li><span class="code">existingListElement.append(newListItem)</span> : adds new element to <b>end</b> of existing descendants within existing element</li>
                        <li><span class="code">existingListElement.appendChild(newListItem)</span> : adds new element to <b>end</b> of existing descendants within existing element. Only takes new element and not raw text, and returns a value equal to the new node.</li>
                        <li><span class="code">existingListElement.prepend(newListItem)</span> : adds new element to <b>start</b> of existing descendants within existing element</li>
                        <li><span class="code">existingListElement.before(newListItem)</span> : adds new element just <b>before</b> existing element</li>
                        <li><span class="code">existingListElement.after(newListItem)</span> : adds new element just <b>after</b> existing element</li>
                        <li><span class="code">existingListElement.insertBefore(newListItem, existingListItem)</span> : adds new element into descendants of existing element, but places new element immediately <b>before</b> the existingListItem parameter</li>
                        <li><span class="code">existingListElement.insertAdjacentElement('position', newListItem)</span> : parameterized method of <span class="code">.append</span>,<span class="code">.prepend</span>,<span class="code">.before</span>,<span class="code">.after</span>:</li>
                        <ul>
                            <li><span class="code">.insertAdjacentElement('beforebegin', newListItem)</span> : adds new element before targetElement</li>
                            <li><span class="code">.insertAdjacentElement('afterbegin', newListItem)</span> : adds new element inside targetElement in the first position</li>
                            <li><span class="code">.insertAdjacentElement('beforeend', newListItem)</span>  : adds new element inside targetElement in the last position</li>
                            <li><span class="code">.insertAdjacentElement('afterend', newListItem)</span> : adds new element after targetElement</li>
                        </ul>

                    </ul>
                    <li>Change <span class="code">newListItem.textContent</span> or <span class="code">newListItem.style</span> properties as you would any other DOM object (<em>this final step can really happen any time after step 1</em>)</li>
                </ol>
            </ul>

        <h3>Forms</h3>
            <li>HTML form elements capture the typical form functionality, including inputs and buttons, with prebuilt interfaces. Forms, as well as child input elements, can be accessed directly from the DOM using either bracket or dot-notation.</li>
            <li>All elements within a form are identified & referenced using the 'name' property. Additionally, it is a best practice to always form elements, such as inputs and buttons, in a containing form element.</li>
            <ul>
                <li><span class="code">document.userForm["first-name"].value</span></li>
                <li><span class="code">document["userForm"].age.value</span></li>
            </ul>

            <li>Key Elements of interest</li>
            <ul>
                <li class="key-concept">input elements</li>
                <ul>
                    <li>Input Types (Not a comprehensive list):</li>
                    <ul>
                    <li><span class="code">type="text"</span> (default) </li>
                    <ul>
                        <li></li>
                    </ul>
                    <li><span class="code">type="number"</span></li>
                    <ul>
                        <li>Creates an numeric input box that exclusively accepts numbers.</li>
                        <li>Can also min, max, and step counter.</li>
                    </ul>
                    <li><span class="code">type="tel"</span></li>
                    <ul>
                        <li>Practically, this is just a textbox but there are additional available nonstandard properties</li>
                    </ul>
                    <li><span class="code">type="password"</span></li>
                    <ul>
                        <li>Text input, with redacted values on the UI</li>
                    </ul>
                    <li><span class="code">type="date"</span></li>
                    <ul>
                        <li>Initializes a date selector HTML widget</li>
                    </ul>
                    <li><span class="code">type="color"</span></li>
                    <ul>
                        <li>Initializes a color selector HTML widget</li>
                    </ul>
                    <li><span class="code">type="radio"</span></li>
                    <ul>
                        <li>Used for 'either-or' selections, such as sex, martial status, etc.</li>
                        <li>To implement, all possible options must be given the same <span class="code">name</span> property. Additionally, the values associated with each option are captured in the <span class="code">value</span> property.</li>
                        <li> To access from the DOM, you can simply reference the <span class="code">document.formName.radioInputName.value</span> attribute.</li>
                    </ul>
                    <li><span class="code">type="checkbox"</span></li>
                    <ul>
                        <li>Used for multi-selection inputs, such as 'favorite foods' or 'desired vacation spots'</li>
                        <li>To implement, all possible options must be given the same <span class="code">name</span> property. Additionally, the values associated with each option are captured in the <span class="code">value</span> property.</li>
                        <li>To access from the DOM, you must navigate an 'RadioNodeList', where the <span class="code">.checked</span> property is a boolean showing whether or not the field is check, and .value shows the value itself.</li>
                        <li>Example:</li>
                        <ul>
                            <span class="code">const myRadioNodeList = document.formName.checkboxInputName;</span> <br /> 
                            <span class="code">for (let selection of myRadioNodeList) {</span> <br /> 
                            <span class="code">&emsp;&emsp; if (selection.checked){</span> <br /> 
                            <span class="code">&emsp; &emsp; &emsp; favoriteFoods += ", " + selection.value;</span> <br /> 
                            <span class="code">&emsp; }</span> <br />
                            <span class="code">}</span> <br />
                                
                        </ul>
                        
                    </ul>
                    </ul>
                </ul>
                <li class="key-concept">select elements</li>
                <ul>
                    <li>Often used in conjunction with multiple <span class="code">option</span> elements to make a dropdown menu.</li>
                    <li>To access from the DOM, you can simply reference the <span class="code">document.formName.selectName.value</span> attribute.</li>
                </ul>
                <li class="key-concept">button elements</li>
                <ul>
                    <li>Tethered to <span class="code">document.formName</span> by default using the "submit" event</li>
                    <li>By default, the <span class="code">"submit"</span> event refreshed the page upon activation. This can be prevented by adding <span class="code">event.preventDefault();</span> to event's function.</li>
                    <li>Not that a button can also be created by using type="button" within an input element. However, this creates other issues - for example, you can no longer submit the form by hitting the 'return' key. Thus, using button elements is preferred.</li>
                </ul>
            </ul>
            <li>Other notable properties (also a comprehensive list):</li>
            <ul>
                <li><span class="code">required</span></li>
                <ul>
                    <li>Build in validation to require use to add some input before the form will be submitted.</li>
                </ul>
                <li><span class="code">placeholder="some text here"</span></li>
                <ul>
                    <li>Text that will appear by default, but does NOT count as an active string. 
                        E.g., if 'placeholder' is used in conjunction with 'required', the user will need to add their own text for the form to be accepted</li>
                </ul>
                <li><span class="code">pattern="[0-9]{3}-[0-9]{3}-[0-9]{4}"</span></li>
                <ul>
                    <li>RegEx representation of required pattern of input</li>
                    <li>Does not automatically put input in pattern form, rather the burden of matching the pattern is, by default, placed on the user.</li>
                </ul>
            </ul>
        </ul>
    <h2>Node.js</h2>
        <ul>
            <li>Intro</li>
            <ul>
                <li>In a nutshell, node.js allows JS to run the terminal enviroment, which creates an endless array of opprotunties</li>
                <li>.JS files can be ran in CLI using <span class="code">node.js path/to/file/main.js</span></li>
                <li>Limitations:</li>
                <ul>
                    <li>node does not access an HTML's DOM like a src=*.js script does.</li>
                    <li>Can't add/modify/remove html elements in the same manner as the directly linked JS file</li>
                    <li>Can't add/modify/remove html elements in the same manner as the directly linked JS file</li>
                </ul>
                <li>Capabilities - Node is built with existing APIs to perform many tasks that are required in a web server, including:</li>
                <ul>
                    <li> better ways to organize code in reusable pieces </li>
                    <li> ways to deal with files </li>
                    <li> ways to deal with databases </li>
                    <li> ability to communicate over the internet </li>
                    <li> ability to accept requests and send responses (in a consistent and standard way) </li>
                    <li> way to deal with work that takes a long time (server side processing) </li>
                </ul>
            </ul>
            <li>Node Package Manager (NPM)</li>
            <li>NPM streamlines the process of leveraging third-party libraries.</li>
            <ul>
                <li>Initializing NPM and using third-party libraries</li>
                <ol>
                    <li>Navigate to project folder in terminal, then enter <span class="code">npm init -y</span></li>
                    <ul>
                        <li>This will create a <span class="code">package.json</span> file, which officially makes the project be a 'node module'. The JSON file contains meta information about the project, including what packages are used</li>
                    </ul>
                    <li>New packages can then be installed locally by running <span class="code">npm install [package-name]</span></li>
                    <ul>
                        <li>This will automatically add to the <span class="code">dependencies</span> section of the <span class="code">package.json</span></li>
                        <li><a href="https://www.npmjs.com/">npmjs.com</a> is a website to find new libraries</li>
                    </ul>
                    <li>Finally, the add the new package to the .js enviroment, enter <span class="code">const somePackageThatSomeoneElseCreated = require("some-package-that-someone-else-created");</span></li>
                </ol>
            </ul>


        </ul>
    <h2>Basic JavaScript</h2>
        <ul>
            <li class="key-concept">Naming Convention</li>
                <ul>
                    <li>camelCase for all variable and function names. Exception - constructor functions</li>
                    <li>Use 4-spaces to ident code. 2-space is also common</li>
                    <li>add whitespace around all operators</li>
                    <li>Each property of an object is given its own line</li>
                    <li>Add Semicolons after every simple statement. Do NOT include a semicolon after loops, }, func declarations, etc</li>
                    <li>Use logical and meaningful names. Additionally, the following rules apply based on type:</li>
                    <ul>
                        <li>Booleans are often named after questions - "isAlive" or "isPositive"</li>
                        <li>Functions should be given a verb or action word describing its job</li>
                        <li>Arrays should be given plural names</li>
                        <li>Objects should be given singular names</li>
                    </ul>
                    <li>Line comments should be used more often than block comments. Generally, you should reserved block comments for extensive documentation.</li> 
                </ul>
            <li>Data Types</li>
                <ul>
                    <li>Immutable - the underlying data type, not the variable containing the data type, cannot be changed.</li>
                    <ul>
                        <li>Primitive Types:</li>
                        <ul>
                            <li>String: "anything enclosed by double or single quotes"</li>
                            <li>Numeric: 1, 342.342, 0, and <span class="code">NaN</span></li>
                            <li>Boolean: <span class="code">true</span> & <span class="code">false</span></li>
                            <li>BigInt</li>
                            <li>Symbol</li>
                            <li>null</li>
                            <li>undefined</li>
                        </ul>
                        <li>Example:</li>
                        <p class="input code">let stringVar = "jello";</p>
                        <p class="input code">console.log(stringVar);</p>
                        <p class="output code">jello</p>
                        <p class="input code">console.log(stringVar[0]);</p>
                        <p class="output code">j</p>
                        <p class="input code">stringVar[0] = "h";</p>
                        <p class="input code">console.log(stringVar);</p>
                        <p class="output code">jello</p>
                        <li>Passed by value</li>
                        <p class="input code">let age = 10;</p>
                        <p class="input code">let OtherAge = age;</p>
                        <p class="input code">otherAge = 12;</p>
                        <p class="input code">console.log(otherAge);</p>
                        <p class="output code">12</p>
                        <p class="input code">console.log(age);</p>
                        <p class="output code">10</p>
                    </ul>
                    <li>Mutable - data can changed. These two are effectively 'containers' in JS</li>
                    <ul>
                        <li>Reference Data Types</li>
                        <ul>
                            <li>Array (typeof will return 'object')</li>
                            <li>Object</li>
                            <li>Functions</li>
                        </ul>
                        <li>Example:</li>
                        <p class="input code">let numericArray = [1, 2, 3, 4];</p>
                        <p class="input code">console.log(numericArray);</p>
                        <p class="output code">[ 1, 2, 3, 4 ]</p>
                        <p class="input code">numericArray[0] = 99;</p>
                        <p class="input code">console.log(numericArray);</p>
                        <p class="output code">[99, 2, 3, 4]</p>
                        <p class="input code">let person = {name : "harry", age : 15};</p>
                        <p class="input code">console.log(person);</p>
                        <p class="output code">{ name: 'harry', age: 15 }</p>
                        <p class="input code">person.hasWand = true;</p>
                        <p class="input code">console.log(person);</p>>
                        <p class="output code">{ name: 'harry', age: 15, hasWand: true }</p>
                        <p class="input code">delete person.hasWand;</p>
                        <p class="input code">console.log(person);</p>
                        <p class="output code">{ name: 'harry', age: 15 }</p>
                        <li>Passed by Reference - note that if you reassign an array or object to a new variable, the two objects will be tethered</li>
                        <p class="input code">let newPerson = person;</p>
                        <p class="input code">newPerson.hasWand = true;</p>
                        <p class="input code">console.log(person)</p>
                        <p class="output code">{ name: 'harry', age: 15, hasWand: true }</p>
                    </ul>
                </ul>
            <li>Special Datatype Method</li>
                <ul>
                    <li>Methods that are specific to every string - these are prebuilt functionality that are native to JS</li>
                    <li class="key-concept">Array Methods</li>
                        <ul>
                            <li>Methods that modify the original array in place:</li>
                            <ul>
                                <li><span class="code">arrayVariable.push()</span>: <b>adds</b> new element to end of array. Returns the new length of the array.</li>
                                <li><span class="code">arrayVariable.pop()</span>: 'pops-off' and element - it <b>removes</b> final element from end of array. Returns removed element</li>
                                <li><span class="code">arrayVariable.unshift()</span>: <b>adds</b> new element to beginning of array.</li>
                                <li><span class="code">arrayVariable.shift()</span>: <b>removes</b> first element from beginning of array.</li>
                                <li><span class="code">arrayVariable.splice(startIndex, deleteCount, "optionalElementToAddToArray", "otherElement", ..., "otherElementN")</span>: Allows you to 1.) cut out elements in array and 2.) add new elements. Modifies array by removing <span class="code">deleteCount</span> number of elements from array, starting at <span class="code">startIndex</span>. The third variable is optional - if left out, no new elements will be added.</li>
                            </ul>
                            <li>Methods that do NOT modify the original array in place:</li>
                            <ul>
                                <li><span class="code">arrayVariable.concat(OtherArray)</span>: Combines two arrays into one - returns a new array</li>
                                <li><span class="code">arrayVariable.indexOf("elementInArray")</span>: Returns index of matching argument. Returns -1 if element if there isn't a match.</li>
                                <li><span class="code">arrayVariable.slice(startIndex, endIndex)</span>: Creates a new array starting at startIndex (inclusive) and ending at endIndex (exclusive). The second variable is optional - if left out, slice() will default to the final index + 1.</li>
                                <li><span class="code">arrayVariable.join("optionalSeperator")</span>: Turns an array into a string by concatenating all elements. Argument is a string that will separate each element in the original array. Default is ","</li>
                                <li><span class="code">arrayVariable.reverse()</span>: returns array in reverse order.</li>
                            </ul>
                            <li>Examples:</li>
                            <ul>
                                <li class="key-concept">Set Up:</li>
                                <p class="code input">let arrOfFoods = ["pancakes", "egg", "ice cream", "pizza", "hamburger"];</p>
                                <p class="code input">console.log(arrOfFoods);</p>
                                <p class="code output">[ 'pancakes', 'egg', 'ice cream', 'pizza', 'hamburger' ]</p>  
                                <li class="key-concept">push():</li>
                                <p class="code input">arrOfFoods.push("tacos");</p>
                                <p class="code output">6</p>  
                                <p class="code input">console.log(arrOfFoods);</p>
                                <p class="code output">[ 'pancakes', 'egg', 'ice cream', 'pizza', 'hamburger', 'tacos' ]</p>  
                                <li class="key-concept">pop():</li>
                                <p class="code input">arrOfFoods.pop();</p>
                                <p class="code output">'tacos'</p>  
                                <p class="code input">console.log(arrOfFoods);</p>
                                <p class="code output">[ 'pancakes', 'egg', 'ice cream', 'pizza', 'hamburger' ]</p>  
                                <li class="key-concept">Unshift():</li>
                                <p class="code input">arrOfFoods.unshift("tacos");</p>
                                <p class="code output">6</p>  
                                <p class="code input">console.log(arrOfFoods);</p>
                                <p class="code output">[ 'pancakes', 'egg', 'ice cream', 'pizza', 'hamburger', 'tacos' ]</p>  
                                <li class="key-concept">shift():</li>
                                <p class="code input">arrOfFoods.shift();</p>
                                <p class="code output">'tacos'</p>  
                                <p class="code input">console.log(arrOfFoods);</p>
                                <p class="code output">[ 'pancakes', 'egg', 'ice cream', 'pizza', 'hamburger' ]</p>  
                                <p class="code input">let arrOfDrinks = ["coffee", "whiskey", "water", "beer"];</p> 
                                <p class="code input">const foodsAndDrinks = arrOfFoods.concat(arrOfDrinks);</p>
                                <p class="code input">console.log(foodsAndDrinks);</p>
                                <p class="code output">['pancakes',  'egg', 'ice cream', 'pizza', 'hamburger', 'coffee', 'whiskey', 'water', 'beer']</p>  
                                <li class="key-concept">indexOf():</li>
                                <p class="code input">console.log(foodsAndDrinks.indexOf("pizza"));</p>
                                <p class="code output">3</p>  
                                <p class="code input">console.log(foodsAndDrinks.indexOf("milkshakes"));</p>
                                <p class="code output">-1</p>  
                                <li class="key-concept">slice():</li>
                                <p class="code input">console.log(foodsAndDrinks.slice(0, 3));</p>
                                <p class="code output">[ 'pancakes', 'egg', 'ice cream' ]</p>  
                                <li class="key-concept">join():</li>
                                <p class="code input">console.log("I like :" + foodsAndDrinks.join(", "));</p>
                                <p class="code output">I like :pancakes, egg, ice cream, pizza, hamburger, coffee, whiskey, water, beer</p>  
                                <li class="key-concept">reverse():</li>
                                <p class="code input">console.log(arrOfFoods.reverse());</p>
                                <p class="code output">[ 'hamburger', 'pizza', 'ice cream', 'egg', 'pancakes' ]</p>  
                                <li class="key-concept">splice():</li>
                                <p class="code input">foodsAndDrinks.splice(0, 1, "steak", "potatoes");</p>
                                <p class="code output">['pancakes']</p>  
                                <p class="code input">console.log("Anytime Food & Drinks:" + foodsAndDrinks);</p>
                                <p class="code output">Anytime Food & Drinks:steak,potatoes,egg,ice cream,pizza,hamburger,coffee,whiskey,water,beer</p> 
                            </ul>
                            <li>For a comprehensive list, see <a href="https://www.w3schools.com/jsref/jsref_obj_array.asp">W3 School Array Methods</a></li>
                        </ul>
                    <li class="key-concept">String Methods</li>
                        <ul>
                            <li>Note that, generally, these do not change the original variable. Rather, they return a new value:</li>
                            <ul>
                                <li><span class="code">stringVariable.toUpperCase()</span> and <span class="code">stringVariable.toLowerCase()</span>: returns the string in either upper or lower case.</li>
                                <li><span class="code">stringVariable.concat("string To Concat")</span>: returns the string with the argument concatenated on the back.</li>
                                <li><span class="code">stringVariable.split("deliminatingString")</span>: returns an array that is seperated by the parameter. Note that the splitting character is removed.</li>
                                <li><span class="code">stringVariable.slice(startIndex, endIndex)</span>: Cuts segment of string starting at startIndex (inclusive) and ending at endIndex (exclusive). The second variable is optional - if left out, slice() will default to the final index + 1.</li>
                                <li><span class="code">stringVariable.indexOf()</span>: used to see if, and where, a pattern is within a string. -1 indicates that the pattern was not located.</li>
                            </ul>
                            <li>Examples:</li>
                            <ul>
                                <li class="key-concept">Set up</li>
                                <p class="code input">let employeeName = "John, Smith";</p> 
                                <p class="code input">let phoneNumber = "8091234567";</p>
                                <li class="key-concept">toUpperCase():</li>
                                <p class="code input">employeeName.toUpperCase();</p>
                                <p class="code output">'JOHN, SMITH'</p>  
                                <li class="key-concept">toLowerCase():</li>
                                <p class="code input">employeeName.toLowerCase();</p> 
                                <p class="code output">'john, smith'</p>  
                                <li class="key-concept">concat():</li>
                                <p class="code input">employeeName.concat(" II");</p> 
                                <p class="code output">'John, Smith II'</p> 
                                <li class="key-concept">split():</li>
                                <p class="code input">employeeName.split(",");</p>  
                                <p class="code output">[ 'John', ' Smith' ];</p>  
                                <li class="key-concept">slice():</li>
                                <p class="code input">phoneNumber.slice(0, 3) + "-" + phoneNumber.slice(3, 6) + "-" + phoneNumber.slice(6)</p>  
                                <p class="code output">'809-123-4567'</p>  
                                <li class="key-concept">indexOf():</li>
                                <p class="code input">employeeName.indexOf(" ");</p> 
                                <p class="code output">5</p> 
                                <p class="code input">employeeName.indexOf("z");</p> 
                                <p class="code output">-1</p> 
                            </ul>
                            <li>For a comprehensive list, see <a href="https://www.w3schools.com/jsref/jsref_obj_string.asp">W3 School String Methods</a></li>
                        </ul>
                </ul>
            <li class="key-concept">Constructor Functions</li>
                <ul>
                    <li>In same manner as an strictly typed OOP language, constructors allow us to create blueprints for objects</li>
                    <li>By convention, constructor function names start with a capital letter</li>
                    <li>Just like in Java, <span class="code">this.objectAttribute</span> is used to declare a standard value within the constructor function</li>
                    <li>Also in Java, we can add methods to the constructor function that will be accessible by all objected created. However, it is bad practice to define methods within constructor function. The more appropraite way is to use the <span class="code">prototype</span>.</li>
                    <li>After creating a constructor function, new instances of the object can be created using the <span class="code">new</span> keyword. See example below.</li>
                    <li>Example</li>
                    <p class="code input">function Car(make, model, year, honkSound) { </p>
                    <p class="code input-indent">this.make = make;</p>
                    <p class="code input-indent">this.model = model;</p>
                    <p class="code input-indent">this.year = year;</p>
                    <p class="code input-indent">this.honkSound = honkSound;</p>
                    <ul>
                        <li>This is the old school way of adding methods. Generally, it is frowned upon because the underlying method will be stored N number of times in memory. The preferred way of implementing methods is to use prototypes.</li>
                    </ul>
                    <p class="code input-indent">this.honk = function(){console.log(this.honkSound + "!")}</p>
                    <p class="code input-indent">}</p>
                    <p class="code input">let jeep = new Car("Jeep", "Cherokee", 1995, "BEEP");</p>
                    <p class="code input">console.log(jeep);</p>
                    <p class="code output">Car { make: 'Jeep', model: 'Cherokee', year: 1995, honkSound: 'BEEP', honk: [Function (anonymous)] }</p>
                    <p class="code input">jeep.honk();</p>
                    <p class="code output">"BEEP"</p>
                    <p class="code input">let honda = new Car("Honda", "Accord", 2019, "MEEP");</p>
                    <p class="code input">console.log(honda);</p>
                    <p class="code output">Car { make: 'Honda', model: 'Accord', year: 2019, honkSound: 'MEEP', honk: [Function (anonymous)] }</p>
                    <p class="code input">honda.honk();</p>
                    <p class="code output">"MEEP"</p>
                    <ul>
                        <li>Prototype implementation (also how inheritance is acheived in JS):</li>
                    </ul>
                    <p class="code input">Car.prototype.betterHonk = function(){console.log(this.honkSound + "!!!!")}</p>
                    <p class="code input">jeep.betterHonk()</p>
                    <p class="code output">BEEP!!!!</p>
                </ul>
            <li class="key-concept">Special Loops</li>
                <ul>
                    <li class="key-concept">'For-Of' Loop</li>
                    <ul>
                        <li>Can be used on any iterable object with an index, such as an array or string</li>
                        <li>Elements are visited in sequential order</li>
                        <li>Cannot be used on elements that don't have an ordinal index, such as an object</li>
                        <li>Example:</li>
                        <p class="code input">const someIterable = [1, 2, 3, 4, 5];</p> <br />
                        <p class="code input">for (element of someIterable) {<br/>console.log(element)<br/>}</p>
                        <p class="code output">1</p>
                        <p class="code output">2</p>
                        <p class="code output">3</p>
                        <p class="code output">4</p>
                        <p class="code output">5</p>
                        <li>Example: </li>
                    </ul>
                    <li class="key-concept">'For-In' Loop</li>
                    <ul>
                        <li>Iterates over <b>keys</b> in an object</li>
                        <li>Effectively the same as 'for each' in Java</li>
                        <li>Elements are visited in a nonsequential order based on implementation, so don't rely on a specific sequence.</li>
                        <li>Prototype properties and standard keys are included in loop, however, certain other elements are not.</li>
                        <li>Note that the 'For-In' loop can be used for arrays, but the resulting element is the index number:</li>
                        <li class="key-concept">Examples - Objects:</li>
                        <p class="code input">const companyRoster = {EID1 : "Jack", EID2 : "Jill", EID3 : "Pete", EID4 : "Susan"}</p>
                        <p class="code input">for (employee in companyRoster) {<br/>console.log(employee);<br/>}</p>
                        <p class="code output">EID1</p>
                        <p class="code output">EID2</p>
                        <p class="code output">EID3</p>
                        <p class="code output">EID4</p>
                        <p class="code input">for (employee in companyRoster) {<br/>console.log(companyRoster[employee]);<br/>}</p>
                        <p class="code output">Jack</p>
                        <p class="code output">Jill</p>
                        <p class="code output">Pete</p>
                        <p class="code output">Susan</p>
                        <li class="key-concept">Example - Arrays:</li>
                        <p class="code input">const someIterable = [1, 2, 3, 4, 5];</p>
                        <p class="code input">for (element in someIterable) {<br/>console.log(element);<br/>}</p>
                        <p class="code output">0</p>
                        <p class="code output">1</p>
                        <p class="code output">2</p>
                        <p class="code output">3</p>
                        <p class="code output">4</p>
                    </ul>
                </ul>
            <li class="key-concept">ES6 Syntax</li>
            <ul>
                <li>JS is updated annually, but ES6 was a major update. ES6 was release in 2015.</li>
                <li class="key-concept">Bracket Scoping: From <span class="code">var</span> to <span class="code">const</span> and <span class="code">let</span></li>
                <ul>
                    <li>ES6 Introducted 'Bracket' Scoping, which allowed variables to live within the nearest set of curly brackets:</li>
                    <ul>
                        <li><span class="code">const</span> For 'constant' variables - cannot be overwritten (but CAN be updated if its an mutable object)</li>
                        <li><span class="code">let</span> For all other variables - can be overwritten and updated.</li>
                    </ul>
                    <li>Before ES6, the only other scoping, aside from Global was Function scoping, where variables were scoped to the nearest function (or problem):</li>
                    <ul>
                        <li><span class="code">var</span> can be overwritten</li>
                    </ul>
                    <li>Bracket versus Function Scoping example:</li>
                    <p class="code input">function scopingExample(){</p>
                    <p class="code input-indent">if (true) {</p>
                    <p class="code input-indent">let a = "i am defined by let within a function's if statement!";</p>    
                    <p class="code input-indent">var b = "i am defined by var within a function's if statement!";</p>    
                    <p class="code input-indent">}</p>                        
                    <p class="code input-indent">typeof a == "undefined" ? console.log("a is undefined...") : console.log(a);</p>
                    <p class="code input-indent">typeof b == "undefined" ? console.log("a is undefined...") : console.log(b);</p>
                    <p class="code input">}</p>
                    <p class="code input">scopingExample()</p>
                    <p class="code output">a is undefined...</p>
                    <p class="code output">i am defined by var within a function's if statement!</p>
                </ul>
                <li class="key-concept">Spread and Rest operators: <span class="code">...</span></li>
                <li>Same operator for both spread and rest</li>
                <li>Rest operator (practically speaking, the rest operator 'gathers' arguments)</li>
                <ul>
                    <li>Combines arguments into a single array in function parameter</li>
                    <li>Example:</li>
                    <p class="code input">function() gatherNumbers(...nums){console.log(nums)}</p>
                    <p class="code input">gatherNumbers(1, 235, 1245, 234);</p>
                    <p class="code output">[ 1, 235, 1245, 234 ]</p>
                </ul>
                <li>Spread - Takes contents of an object or array, then copies contents</li>
                <ul>
                    <li>Whenever <span class="code">...</span> appears outside of a function parameter, it is the Spread operator</li>
                    <li>Directly copies array or object - since they are called by reference, this is a way to make an actual duplicate of an existing array or object.</li>
                    <li>Example:</li>
                    <p class="code input">const colors1 = ["red", "blue"];</p>
                    <p class="code input">const colors2 = ["yellow", "green"];</p>
                    <p class="code input">const allColors = [...colors1, ...colors2];</p>
                    <p class="code input">console.log(allColors)</p>
                    <p class="code output">[ 'red', 'blue', 'yellow', 'green' ]</p>
                </ul>
                <li><span class="code">import</span> and <span class="code">export</span></li>
                <ul>
                    <li>Essentially, these are the equivalent to <span class="code">require()</span> and <span class="code">module.exports</span> used in node, however <span class="code">import</span> and <span class="code">export</span> are specific to native JS.</li>
                </ul>
                <li class="key-concept">The ES6 Fat Arrow Function</li>
                    <ul>
                        <li>Best practice is to arrow functions in place of all standard anonymous functions, and most other functions expressions.</li>
                        <li>Basically, remove <span class="code">function</span> keyword and replace assignment operator with an arrow ("=>")</li>
                        <li>If there is a single argument, the parentheses can be deleted</li>
                        <li>If there is a single line with a return, the <span class="code">return</span> keyword can be deleted. This is known as an 'implicit return'</li>
                        <li>Exmaples:</li>
                        <ul>
                            <li>Traditional Named Function:</li>
                            <span class="code">function typicalNamedFunction(){return "Clicked!"}</span>
                            <li>Named ES6 Arrow Function Equivalent, with implicit return:</li>
                            <span class="code">let typicalNamedFunction = () => "Clicked!";</span>
                            <li>Traditional Anonymous Function:</li>
                            <span class="code">function(){return "Clicked!"}</span>
                            <li>Anonymous ES6 Arrow Function Equivalent, with implicit return:</li>
                            <span class="code">() => "Clicked!";</span>
                            <li>Named ES6 Arrow Function with one argument:</li>
                            <span class="code">let whoClicked = name => name + " clicked the element!";</span>
                            <li>Named ES6 Arrow Function with two or more arguments:</li>
                            <span class="code">let whoLikesClicking = (nameFirst, nameSecond) => nameFirst + " and " + nameSecond + " enjoy clicking elements!";</span>
                            
                        </ul>
                        
                    </ul>
                <li class="key-concept">Object Literals</li>
                    <ul>
                        <li>Object literals allow you to add elements to an object that have the same name for both the value and key by simply adding it within the curly brackets based on an existing variable (e.g., instead of <span class="code">Red : "Red"</span>, you can simply type <span class="code">Red</span></li>
                    </ul>
                <li class="key-concept">Object Destructuring</li>
                    <ul>
                        <li>Mitigates the redundant calling of child nodes that are located deep within a nested object</li>
                        <li>Object Destructuring syntax goes <span class="code">const {keyName1, keyName2, ..., keyNameN} = someObject</span></li>
                        <li>Array Destructuring syntax goes <span class="code">const [element1, element2, ..., elementN] = someArray</span>. Note that for Array destructuring, you can name the elements whatever you want.</li>
                        <li>Example</li>
                        <p class="code input">const user =  {</p>
                        <p class="code input-indent">userName: "petemiller1934", </p>
                        <p class="code input-indent">age: 20, </p>
                        <p class="code input-indent">_id: "asfasgfsjdhgjwgdsdf" </p>
                        <p class="code input">}</p>
                        <p class="code input">const {_id, userName, age} = user;</p>
                        <p class="code input">console.log(_id)</p>
                        <p class="code output">asfasgfsjdhgjwgdsdf</p>
                        <p class="code input">console.log(userName)</p>
                        <p class="code output">petemiller1934</p>
                        <p class="code input">console.log(age)</p>
                        <p class="code output">20</p>
                    </ul>
                <li class="key-concept">Default parameters</li>
                    <ul>
                        <li>ES6 brought on default parameters... it works exactly like anybody would expect.</li>
                    </ul>
            </ul>
        </ul>
    <h2>Advanced JS Concepts</h2>
        <ul>
            <li class="key-concept">Web Storage</li>
            <ul>
                <li>Methods of implementing persistent data in a web browser</li>
                <ul>
                    <li>Cookies: Typically meant to store information about HTTP requests - they are sent in the headers HTTP requests. Limited to 4kb, but one advantage is that they can have a set expiration so they will die at a specified date/time</li>
                    <li>Database: Most robust option, but there is a lot more overhead with respect to set-up/maintenance (have to set up a separate server and obviously a database). Ideal for large scale/production applications, but could be overkill for smaller projects</li>
                    <li>Local Storage: Browser is able to store basic Key-Value pairs to local hard drive. Can hold basically as much data as you want to put in it and will continue to persist until it is manually cleared out. This is ideal for saving user's customized settings.</li>
                    <li>Session Storage: Identical to Local Storage except that data will be removed once the browser is (since data is specific to the session). However, this might be useful because a user can have more than one window open and still have data shared between them.</li>
                <li>Using <span class="code">localStorage</span> and <span class="code">sessionStorage</span> - Save, Access, and Removing something:</li>
                    <p class="input code">localStorage.setItem("keyName", "valueToSaveToLocalStorage");</p>
                    <p class="input code">sessionStorage.setItem("keyName", "valueToSaveToSessionStorage");</p>
                    <p class="input code">console.log(localStorage.getItem("keyName"));</p>
                    <p class="output code">valueToSaveToLocalStorage</p>
                    <p class="input code">console.log(sessionStorage.getItem("keyName"));</p>
                    <p class="output code">valueToSaveToSessionStorage</p>
                    <p class="input code">sessionStorage.removeItem("keyName");</p>
                    <p class="input code">// Alternatively, you can access, modify, and delete the values the same way you would with any JS object:</p>
                    <p class="input code">localStorage.keyName = "Updated value string";</p>
                    <p class="input code">console.log(localStorage.keyName);</p>
                    <p class="output code">Updated value string</p>
                    <p class="input code">delete localStorage.keyName;</p>
                <li>The getter and setter methods return <span class="code">null</span> if object is not defined, whereas the other methods return <span class="code">undefined</span>, which is harder to handle. With that, it is best to use the getter and setter methods.</li>
                <li>Note <span class="code">localStorage</span> and <span class="code">sessionStorage</span> are limited to primitive data types. If needed, you can use <span class="code">JSON.stringify()</span> and <span class="code">JSON.parse()</span> to transform arrays & objects to/from JSON</li>
                    <p class="input code">const anObject = {name : "Pete", age : 18};</p>
                    <p class="input code">sessionStorage.setItem("friend", JSON.stringify(anObject));</p>
                    <p class="input code">console.log(JSON.parse(sessionStorage.friend));</p>
                    <p class="output code">{name: 'Pete', age: 18}</p>
                </ul>
            </ul>
            <li><span class="key-concept">Higher Order Functions</span> Functions functions that either takes a function as an argument and/or returns a functions.</li>
            <ul>
                <li>Higher Order Functions will often use a <span class="key-concept">callback</span>, or a function that will implement the logic. Think Command Pattern.</li>
                <li><span class="code">setTimeout</span> and <span class="code">setInterval</span></li>
                <ul>
                    <li>Provide a means to program delays - e.g., wait 10 seconds before running a given function. Note that the <span class="code">time</span> argument is in milliseconds</li>
                    <li><span class="code">setTimeout</span> - Calls a function after a certain amount of time</li>
                    <ul>
                        <li>Ideal for delaying the execution of a function once (e.g., function will 1 time, but will wait 60 seconds before executing).</li>
                    </ul>
                    <li><span class="code">setInterval</span> - Calls a function on a repeated basis</li>
                    <ul>
                        <li>Ideal for delaying the execution of a function multiple times (e.g., function will run 100 times, every 60 seconds).</li>
                    </ul>
                    <li>Both functions return an ID, which can be used to stop the timers - <span class="code">clearInterval</span> and <span class="code">clearTimeout</span></li>
                </ul>
                <li>Higher Order Array Methods:</li>
                <ul>
                    <li><span class="code">.map()</span></li>
                    <ul>
                        <li>Purpose: allows you to apply a function to each element within a given array - in essence, it is a shorter syntax for a for-loop</li>
                        <li>Returns: an array of equal length to the original array</li>
                        <p class="input code">const arr = [1, 2, 3, 4, 5];</p>
                        <p class="input code">console.log(arr.map(num => num + 10))</p>
                        <p class="output code">[ 11, 12, 13, 14, 15 ]</p>
                        <p class="input code">const users = [{name : "john"}, {name : "pete"}];</p>
                        <p class="input code">console.log(users.map(user => user.name));</p>
                        <p class="output code">[ 'john', 'pete' ]</p>
                    </ul>
                    <li><span class="code">.filter()</span></li>
                    <ul>
                        <li>Purpose: Reducing an existing data set into a subset. Note that the callback function needs to return true or false</li>
                        <li>Returns: A new array with only the filtered items</li>
                        <p class="input code">const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];</p>
                        <p class="input code">console.log(arr.filter(num => (num % 2) === 0));</p>
                        <p class="output code">[ 2, 4, 6, 8, 10 ]</p>
                        <p class="input code">const movies = [</p>
                        <p class="input-indent code">{ name: "movie1", genre: "horror" },</p>
                        <p class="input-indent code">{ name: "movie2", genre: "action" },</p>
                        <p class="input-indent code">{ name: "movie3", genre: "action" },</p>
                        <p class="input-indent code">{ name: "movie4", genre: "fantasy" }</p>
                        <p class="input code">];</p>
                        <p class="input code">console.log(movies.filter(movie => movie.genre === "action"));</p>
                        <p class="output code">[{ name: 'movie2', genre: 'action' }, { name: 'movie3', genre: 'action' }]</p>
                    </ul>
                    <li><span class="code">.ForEach()</span></li>
                    <ul>
                        <li>Purpose: Similar to map except that it does NOT return a new array. Is used in place of a for-loop - </li>
                        <li>Returns: <span class="code">undefined</span></li>
                        <p class="input code">const arr = [1, 2, 3, 4, 5, 6, 7, 8]</p>
                        <p class="input code">const newArr = [];</p>
                        <p class="input code">arr.forEach(num => (num % 2) === 0 && newArr.push(num))</p>
                        <p class="input code">console.log(newArr);</p>
                        <p class="output code">[ 2, 4, 6, 8 ]</p>
                    </ul>
                    <li><span class="code">.find()</span></li>
                    <ul>
                        <li>Purpose: Finding an item within an array</li>
                        <li>Returns: The first match that is found within the array</li>
                        <p class="input code">const users = [</p>
                        <p class="input-indent code">{ name: "joe"},</p>
                        <p class="input-indent code">{ name: "julie"},</p>
                        <p class="input-indent code">{ name: "rick"}</p>
                        <p class="input code">];</p>
                        <p class="input code">console.log(users.find(user => user.name[0] === "j"))</p>
                        <p class="output code">{ name: 'joe' }</p>
                    </ul>
                    <li><span class="code">.findIndex()</span></li>
                    <ul>
                        <li>Purpose: Finding an index number of a given element within an array</li>
                        <li>Returns: the index number of the matching element</li>
                        <p class="input code">const users = [</p>
                        <p class="input-indent code">{ name: "joe"},</p>
                        <p class="input-indent code">{ name: "julie"},</p>
                        <p class="input-indent code">{ name: "rick"}</p>
                        <p class="input code">];</p>
                        <p class="input code">console.log(users.find(user => user.name[0] === "j"))</p>
                        <p class="output code">0</p>
                    </ul>
                    <li><span class="code">.every()</span></li>
                    <ul>
                        <li>Purpose: Test to see if something exists within an array. Continues to loop through array until a failure is found.</li>
                        <li>Returns: Returns <span class="code">true</span> if at least item in array matches criteria.  </li>
                        <p class="input code">const names = ["Jack", "John", "Jill", "Joseph", "Jackie", "Steve"];</p>
                        <p class="input code">const namesNoSteve = ["Jack", "John", "Jill", "Joseph", "Jackie"];</p>
                        <p class="input code">console.log(names.some(name => name[0] === "J"));</p>
                        <p class="output code">false</p>
                        <p class="input code">console.log(namesNoSteve.some(name => name[0] === "J"));</p>
                        <p class="output code">true</p>
                    </ul>
                    <li><span class="code">.some()</span></li>
                    <ul>
                        <li>Purpose: Test contents of array for complete match</li>
                        <li>Returns: Returns <span class="code">true</span> if EVERY item in array matches criteria.  </li>
                        <p class="input code">const names = ["Jack", "John", "Jill", "Joseph", "Jackie", "Steve"];</p>
                        <p class="input code">console.log(names.some(name => name[0] === "S"));</p>
                        <p class="output code">true</p>
                    </ul>
                    <li><span class="code">.sort()</span></li>
                    <ul>
                        <li>Purpose: To sort an unsorted array</li>
                        <li>Returns: The array but sorted... But it also mutates the original array in place. Capturing the value isn't entirely important. Sort algorithm is browser dependent. The syntax is a little weird, so you may have to play around with it.</li>
                        <p class="input code">const arr = [34, 6, 22, 1, 6, 44, 3, 64, 234, 5];</p>
                        <p class="input code">arr.sort((a, b) => b - a);</p>
                        <p class="input code">console.log(arr);</p>
                        <p class="output code">[234, 64, 44, 34, 22, 6,  6,  5,  3,  1]</p>
                        <p class="input code">arr.sort((a, b) => a - b);</p>
                        <p class="input code">console.log(arr)</p>
                        <p class="output code">[1, 3, 5, 6, 6, 22, 34, 44, 64, 234 ]</p>
                    </ul>
                    <li><span class="code">.reduce(function(final, current){}, initialValueOfFinal)</span> - initial value is optional</li>
                    <ul>
                        <li>Purpose: Takes an array of data and reduces it into a smaller or completely different data set.</li>
                        <li>Returns: Can return virtually anything depending on how it is used</li>
                        <li>Common naming convention - 'final' is what is returned from .reduce() while 'current' represents each individual element. 'current' should be changed to a meaningful name</li>
                        <li>Second argument is optional. if left as default or not specified, 'final' is initialized as the data type of the first element in the array.</li>
                        <li>Whatever is returned at the end of each element's iteration becomes the new value of 'final' for the next iteration. If there aren't any other iterations, the value is returned.</li>
                        <p class="input code">const arr = [1, 2, 3, 4, 5];</p>
                        <p class="input code">const result1 = arr.reduce((final, current) => final += current, 0)</p>
                        <p class="input code">console.log(result1)</p>
                        <p class="output code">15</p>
                        <p class="input code">arr.reduce((final, current) => {</p>
                        <p class="input-indent code">console.log(`Starting final value: ${final}`);</p>
                        <p class="input-indent code">final += current;</p>
                        <p class="input-indent code">console.log(`current: ${current}`);</p>
                        <p class="input-indent code">console.log(`Ending final value: ${final}`);</p>
                        <p class="input-indent code">return final;</p>
                        <p class="input-indent code">}) // no value of final was initialized, so it will be 0 on the first iteration.</p>
                        <p class="output code">Starting final value: 0</p>
                        <p class="output code">current: 1</p>
                        <p class="output code">Ending final value: 1</p>
                        <p class="output code">Starting final value: 1</p>
                        <p class="output code">current: 2</p>
                        <p class="output code">Ending final value: 3</p>
                        <p class="output code">Starting final value: 3</p>
                        <p class="output code">current: 3</p>
                        <p class="output code">Ending final value: 6</p>
                        <p class="output code">Starting final value: 6</p>
                        <p class="output code">current: 4</p>
                        <p class="output code">Ending final value: 10</p>
                        <p class="output code">Starting final value: 10</p>
                        <p class="output code">current: 5</p>
                        <p class="output code">Ending final value: 15</p>
                        <p class="input code">const voters = [</p>
                        <p class="input-indent code">{ name: "steve", voted: true },</p>
                        <p class="input-indent code">{ name: "janet", voted: true },</p>
                        <p class="input-indent code">{ name: "rebecca", voted: false },</p>
                        <p class="input-indent code">{ name: "harvey", voted: true },</p>
                        <p class="input-indent code">]</p>
                        <p class="input code">const result4 = voters.reduce((final, voter) => {</p>
                        <p class="input-indent code">if (voter.voted === true) {</p>
                        <p class="input-indent code">final.didVote += 1;</p>
                        <p class="input-indent code">} else {</p>
                        <p class="input-indent code">final.didntVote += 1;</p>
                        <p class="input-indent code">}</p>
                        <p class="input-indent code">return final;</p>
                        <p class="input-indent code">},</p>
                        <p class="input-indent code">{didVote : 0, didntVote : 0}) // initalizing the value of 'final'</p>
                        <p class="input code">console.log(result4);</p>
                        <p class="output code">{ didVote: 3, didntVote: 1 }</p>
                    </ul>

                </ul>
                
            </ul>
            <li class="key-concept">Error Handling</li>
            <ul>
                <li>Error handling works exactly the same as in Java.. and very similar to R.</li>
                <li>Overview</li>
                <ul>
                    <li><span class="code">try{}</span> Default code block that will be run</li>
                    <li><span class="code">catch{}</span> Code block that will be run in the event of a thrown error</li>
                    <li><span class="code">finally{}</span> Code block that will run regardless of whether or not an error was throw</li>
                    <li><span>throw</span> Keyword that precedes the throwing of a new error. Can be placed before a string or an instantiated error.</li>
                    <li><span>new Error()</span> constructor to instantiate new error obect</li>
                </ul>
                <li>List of error types native to JS - see <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors">here</a> for full list.</li>
                <ul>
                    <li><span class="code">Error</span></li>
                    <li><span class="code">InternalError</span></li>
                    <li><span class="code">RangeError</span></li>
                    <li><span class="code">ReferenceError</span></li>
                    <li><span class="code">SyntaxError</span></li>
                    <li><span class="code">TypeError</span></li>
                    <li><span class="code">URIError</span></li>
                    <li><span class="code">Warning</span></li>
                </ul>
            </ul>
            <li class="key-concept">Unit Testing</li>
            <ul>
                <li>Practice of testing the smallest unit possible (e.g., function) by evaluating the input/expected output.</li>
                <li>Benefits of Unit Testing</li>
                <ul>
                    <li>Approaching a program with testing in mind creates an stronger overall program as you are approaching each individual section with tests.</li>
                    <li>Catch bugs earlier on.</li>
                    <li>Forces you to write out expected output, thereby making code easier to understand</li>
                    <li>Streamlines the addition of new features/refactoring since you can further encapsulate expected results at the smallest level possible.</li>
                    <li>Protects code against other developers through changes - everyone can see right away if something breaks after someone makes a change.</li>
                </ul>
                <li>Test Driven Development (TDD), or Red/Green Testing</li>
                <ul>
                    <li>TDD is a method that requires the test to be written before the function is even created</li>
                    <li>At first, test will fail, thereby producing a 'red' in the console</li>
                    <li>As time goes on, the results turn green which shows everything is working as expected/desired.</li>
                    <li>The idea is to have the testing methodology in mind before even starting with the function.</li>
                </ul>
                <li>Frameworks - There are many available, but V School uses <span class="key-concept">Mocha</span> and <span class="key-concept">Chai</span></li>
                <ul>
                    <li>Mocha - Test runner, shows how many passed and which ones failed.</li>
                    <li>Chai - Assertion library including <span class="code">assert</span>, <span class="code">expect</span>, and <span class="code">should</span></li>
                </ul>
            </ul>

        </ul>

    </body>
</html>